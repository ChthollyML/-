## <font color="#000000">浏览器是一个多进程多线程的应用</font>
浏览器为了避免相互影响，减少连环崩坏的几率，自动启动多个进程
![[附件/事件循环/image-20240228103433038.png]]
最主要的进程：
1. 浏览器进程
主要负责浏览器页面显示，用户交互，子进程管理。浏览器进程会启动其他多个线程。
2. 网络进程
负责加载网络资源。
3. 渲染进程
渲染进程启动后，会开启一个渲染主线程，负责执行 HTML、CSS、JS 代码，每个人标签页会产生一个新的渲染进程
## 渲染主线程如何工作
渲染主线程是最繁忙的线程，处理的任务包括但不限于：
- 解析 HTML
- 解析 CSS
- 计算样式
- 布局
- 处理图层
- 每秒画页面 60 次
- 全局执行 JS 代码
- 执行事件处理函数
- 执行回调函数
- ........

>  **为什么渲染主线程不采用多线程管理？**

如何处理任务？排队
![[附件/事件循环/image-20240228105523065.png]]
1. 最开始的时候，渲染主线程会进入一个无限循环
2. 每一次循环检查消息队列里有没有任务存在，先进先出
3. 其他所有线程可以随时向消息队列添加任务，若主线程休眠，则将其唤醒执行任务

这整个过程称为事件循环（消息循环）

## 何为异步？
在代码执行中，会遇到一些无法立即执行的任务：
- 计时后执行的任务 -- `setTimeout`
- 网络请求完成后执行的任务  -- `Fetch`
- 用户操作后执行的任务 -- `function`

如果让主线程等待这些任务，那么会造成主线程阻塞
![[附件/事件循环/image-20240228110451261.png]]
因此，浏览器选择异步解决问题
![[附件/事件循环/image-20240228110926097.png]]
> **如何理解 JS 的异步？**
> 回答： 首先 JS 是一个单线程的语言，因为其运行在浏览器的渲染主线程上，而渲染主线程只有一个。而渲染主线程是非常忙碌的，其要执行渲染页面，执行 JS 等任务，如果采有同步的方式就极容易造成主线程的阻塞，页面卡死。
> 因此浏览器采用异步的方式来避免这种情况，具体做法是在某些任务发生后，将任务交由其他线程去执行，自身立即结束当前任务，转而去执行后续代码，当该任务完成时，其他线程采用回调函数将任务添加到消息队列末尾排序等待主线程的再次调度执行。
> 在这种异步模式下，浏览器不会发生阻塞，最大程度保证了单线程的流程运行

### JS 为何会阻碍渲染
因为 JS 执行和渲染任务都在渲染主线程上执行，需要排队
### 任务有优先级吗？
任务没有优先级，在消息队列中按先进先出顺序
但是消息队列有优先级
在目前的 Chrome 实现中，包含了如下队列：
- 延时队列： 存放计时器的回调任务，优先级中
- 交互队列：存放用户操作后产生的任务，优先级高
- 微队列：用户存放需要最快执行的任务，优先级最高
