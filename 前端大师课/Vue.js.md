``` javascript
var vm = new Vue({
	el:'.container',
	data:{
	//界面数据 
	//数据响应式：数据变动自动运行相关函数
	title:"shuju",
	
	}
})
```

```HTML
<div v-for="item in goods"
	 class="list-item"
	 :class="{
	 active:item.choose>0 //更换某个特别的样式
	 }">
	<div/>
</div>
```

> Vue 2 是如何做到数据响应式的
> 通过 `object.defineProprety` 对对象设置是 `set` 和 `get` 方法
> 当有数据改变时，调用 `set` 方法更改值
> 但是页面此时还没有同步渲染，还要运行所有的渲染这个数据的函数
> 如何得到这些函数呢？
> **调用了 `get` 方法之后，会将属性对应的 `watch` 记录，每当执行 `set` 时会通知 `watch` 去调用对应的 `render` 渲染函数**
> 
> 视频里教的：
> 当函数中用到了某个属性调用 `get` 方法，将该函数的名称放入 `set()` 集合中，在 `set` 方法中去遍历这些函数
> 但是还是不知道具体是哪个函数调用的，于是采用第三方变量 `window.__fun` 来存储函数名，当这个函数执行时，设置 `window.__func` 值，函数运行结束时设为 `null`，这样在 `get` 方法中就能拿到函数名称了
> **事先**用 `autoRun` 来自动处理 `window.__fun` 的值，这样就不用每个函数都写一遍了，并且也存储了函数的名称

**Vue 2 双向数据绑定：**
Object.Defineproprety
现有 observer 遍历文档节点，将每个数据对象的所有属性都设置 setter 和 getter 方法，然后对这些属性进行监听，一旦触发了这些方法就会去通知监听这个属性的 watcher 订阅者
订阅者收到通知后会调用渲染该属性视图的 update 方法来进行视图的更新，拿这个方法是怎么和订阅者绑定的呢？
是通过 complie 对某一节点的指令进行解析，将视图中的变量替换为模型中的数据，然后初始化视图模型，并且生成一个 update 方法来更新这个节点的视图，最后将这个节点与订阅者 watcher 绑定，并且给 watcher 添加 update 方法
**Vue 3 双向数据绑定**
Vue 3 是通过 ES 6 中的 proxy 进行数据绑定，proxy 是一个代理对象，用它对已有数据进行代理，也就是我们不在直接操作原有的数据，而是操作这个代理对象，通过这个代理对象内置的读写等方法来对原数据进行修改。比如我们修改代理的某一个属性值，会触发这个代理的 set 方法，在这个 set 方法中把使用 reflect （反射）的 set 方法来修改原数据的值
**Vue 3 与 vue 2 的区别和优点**
首先 vue 2 的 defineProprety 只能监听对象的某一属性，因此要想实现对象响应式必须要遍历其所有属性，这就会产生性能问题。
同时 vue 2 的响应式无法监听属性的增加删除，和数组的下标变化。

由于 Vue 3 是使用 proxy 来代理整个对象，因此不需要遍历所有的属性，有性能提升，而且 proxy 可以监听到属性的增加删除，以及数组的问题。
Proxy 是代理对象，因此 vue 3 中不会直接污染原数据。
